/*
 * Copyright (c) 2025 Siemens Mobility GmbH
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <mem.h>
#include <freq.h>
#include <arm/armv7-r.dtsi>
#include <zephyr/dt-bindings/interrupt-controller/ti-vim.h>

/ {
	cpus {
		#address-cells = <1>;
		#size-cells = <0>;

		cpu@0 {
			device_type = "cpu";
			compatible = "arm,cortex-r5";
			reg = <0>;
			clock-frequency = <DT_FREQ_M(800)>;
			i-cache-line-size = <DT_SIZE_K(8)>;
			d-cache-line-size = <DT_SIZE_K(8)>;
		};
	};

	pinctrl: pinctrl@f4000 {
		compatible = "ti,k3-pinctrl";
		reg = <0x000f4000 0x2ac>;
		status = "okay";
	};

	// SRAM the core runs exclusively on. No other core should access this
	sram_core: memory@70080000 {
		reg = <0x70080000 DT_SIZE_K(256)>;
	};

	// SRAM that could be used by all cores. Atomic instructions (e.g. LDREX)
	// don't work due to how the SRAM is connected!
	sram_shared: memory@70180000 {
		reg = <0x70180000 DT_SIZE_K(256)>;
	};

	// SRAM where the bootloader ran. Could be used, if needed
	sram_bootloader: memory@70000000 {
		reg = <0x70000000 (DT_SIZE_K(256) * 2)>;
	};

	// When not changing the reset vector it's located at 0x0 which is inside the ATCM. To be
	// able to use it for the reset vector and code/data it's split up into two chunks
	atcm_boot: memory@0 {
		device_type = "memory";
		compatible = "mmio-sram";
		reg = <0x0 DT_SIZE_K(1)>;
	};

	atcm: memory@400 {
		device_type = "memory";
		compatible = "zephyr,memory-region", "mmio-sram";
		reg = <0x400 DT_SIZE_K(31)>;
		zephyr,memory-region = "ATCM";
		zephyr,memory-region-flags = "rwx";
	};

	btcm: memory@41010000 {
		device_type = "memory";
		compatible = "zephyr,memory-region", "mmio-sram";
		reg = <0x41010000 DT_SIZE_K(32)>;
		zephyr,memory-region = "BTCM";
		zephyr,memory-region-flags = "rwx";
	};

	gpio0: gpio@600010 {
		compatible = "ti,davinci-gpio";
		reg = <0x00600010 0x100>;
		gpio-controller;
		#gpio-cells = <2>;
		status = "disabled";
	};

	gpio1: gpio@601010 {
		compatible = "ti,davinci-gpio";
		reg = <0x00601010 0x100>;
		gpio-controller;
		#gpio-cells = <2>;
		status = "disabled";
	};

	mspi0: mspi@fc40000 {
		compatible = "ti,k3-mspi-controller";
		reg = <0x0fc40000 0x100 0x60000000 0x4>;
		sram-allocated-for-read = <0x80>;
		status = "disabled";
	};

	uart0: uart@2800000 {
		compatible = "ns16550";
		reg = <0x02800000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 210 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	uart1: uart@2810000 {
		compatible = "ns16550";
		reg = <0x02810000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 211 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	uart2: uart@2820000 {
		compatible = "ns16550";
		reg = <0x02820000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 212 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	uart3: uart@2830000 {
		compatible = "ns16550";
		reg = <0x02830000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 213 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	uart4: uart@2840000 {
		compatible = "ns16550";
		reg = <0x02840000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 214 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	uart5: uart@2850000 {
		compatible = "ns16550";
		reg = <0x02850000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 215 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	uart6: uart@2860000 {
		compatible = "ns16550";
		reg = <0x02860000 0x200>;
		clock-frequency = <DT_FREQ_M(48)>;
		interrupts = <0 216 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		reg-shift = <2>;
		status = "disabled";
	};

	vim: interrupt-controller@2fff0000 {
		#address-cells = <1>;
		compatible = "ti,vim";
		reg = <0x2fff0000 0x2400>;
		interrupt-controller;
		#interrupt-cells = <4>;
		status = "okay";
	};

	// We use timer 11 as Zephyr time source since there is no dedicated one that fulfills the
	// requirements
	systick_timer: timer@24b0000 {
		compatible = "ti,am654-timer";
		reg = <0x024b0000 0x70>;
		interrupts = <0 163 IRQ_TYPE_LEVEL IRQ_DEFAULT_PRIORITY>;
		interrupt-parent = <&vim>;
		status = "okay";
	};

	chosen {
		zephyr,sram = &sram_core;
	};
};
