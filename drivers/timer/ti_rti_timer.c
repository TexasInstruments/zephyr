/* Copyright (c) 2025 Texas Instruments Incorporated
 *
 * SPDX-License-Identifier: Apache-2.0
 */

#include <zephyr/device.h>
#include <zephyr/drivers/timer/system_timer.h>
#include <zephyr/irq.h>
#include <zephyr/sys_clock.h>
#include <zephyr/kernel.h>

#include <zephyr/drivers/timer/ti_rti_timer.h>

#define DT_DRV_COMPAT ti_am26_rtitimer

#define TIMER_IRQ_NUM   DT_INST_IRQN(0)
#define TIMER_IRQ_PRIO  DT_INST_IRQ(0, priority)
#define TIMER_IRQ_FLAGS DT_INST_IRQ(0, flags)

#if defined(CONFIG_TEST)
const int32_t z_sys_timer_irq_for_test = TIMER_IRQ_NUM;
#endif

#define CYC_PER_TICK ((uint32_t)(sys_clock_hw_cycles_per_sec() / CONFIG_SYS_CLOCK_TICKS_PER_SEC))

struct ti_rti_timer_config {
	DEVICE_MMIO_ROM;
};

struct ti_rti_timer_data {
	DEVICE_MMIO_RAM;
};

static const struct device *systick_timer_dev;

#define RTI_REG(reg) (DEVICE_MMIO_GET(systick_timer_dev) + reg)

/* Configure input clock source for selected RTI */
/* NOTE: MSS_RCM registers must be unlocked for clock source selection to take effect */
static void configure_input_clock_source(uint32_t addr)
{
	if (addr == RTI0_BASE_ADDR) {
		sys_write32(0x222, RTI0_CLK_SRC_SEL);
	} else if (addr == RTI1_BASE_ADDR) {
		sys_write32(0x222, RTI1_CLK_SRC_SEL);
	} else if (addr == RTI2_BASE_ADDR) {
		sys_write32(0x222, RTI2_CLK_SRC_SEL);
	} else if (addr == RTI3_BASE_ADDR) {
		sys_write32(0x222, RTI3_CLK_SRC_SEL);
	}
}

static void ti_rti_timer_write_reg_fields(uint32_t data, uint32_t reg, uint32_t mask,
					  uint32_t shift)
{
	uint32_t reg_val;

	reg_val = sys_read32(reg);
	reg_val = (reg_val & ~(mask)) | (data << shift);
	sys_write32(reg_val, reg);
}

static void ti_rti_timer_isr(void *param)
{
	ARG_UNUSED(param);

	/* If no pending event */
	if (!sys_read32(RTI_REG(RTIINTFLAG))) {
		return;
	}

	/* ACK match interrupt (INT0 for an RTI) */
	sys_write32(0x1u, RTI_REG(RTIINTFLAG));

	/* Clear counter 0 overflow interrupt if high */
	if (sys_read32(RTI_REG(RTIINTFLAG)) & RTIINTFLAG_OVL0INT_MASK) {
		sys_write32((0x1u << RTIINTFLAG_OVL0INT_SHIFT), RTI_REG(RTIINTFLAG));
	}

	/* The timer ISR is generated per counter increment, announce that 1 tick has elapsed */
	sys_clock_announce(1);
}

void sys_clock_set_timeout(int32_t ticks, bool idle)
{
	ARG_UNUSED(idle);

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		/* Not supported on tickful kernels */
		return;
	}
}

uint32_t sys_clock_cycle_get_32(void)
{
	return (uint32_t)sys_read32(RTI_REG(RTIFRC0));
}

unsigned int sys_clock_elapsed(void)
{
	/* This driver doesn't support tickless kernel, return 0 for tickful kernel */
	return 0;
}

static int sys_clock_driver_init(void)
{

	systick_timer_dev = DEVICE_DT_GET(DT_ALIAS(systick_timer));

	DEVICE_MMIO_MAP(systick_timer_dev, K_MEM_CACHE_NONE);

	irq_disable(TIMER_IRQ_NUM);

	IRQ_CONNECT(TIMER_IRQ_NUM, TIMER_IRQ_PRIO, ti_rti_timer_isr, NULL, TIMER_IRQ_FLAGS);

	/* Configure input clock source as sys_clock */
	configure_input_clock_source(RTI_REG(0));

	/* Disable Continue on Suspend */
	ti_rti_timer_write_reg_fields(0, RTI_REG(RTIGCTRL), RTIGCTRL_COS_MASK, RTIGCTRL_COS_SHIFT);

	/* COUNTER CONFIGURATION START */

	/* Disable the counter block */
	ti_rti_timer_write_reg_fields(0, RTI_REG(RTIGCTRL), RTIGCTRL_CNT0EN_MASK,
				      RTIGCTRL_CNT0EN_SHIFT);

	/* Clear free-running counter */
	sys_write32(0, RTI_REG(RTIFRC0));

	/* let up-counter be clock source to free-running counter */
	ti_rti_timer_write_reg_fields(0, RTI_REG(RTITBCTRL), RTITBCTRL_TBEXT_MASK,
				      RTITBCTRL_TBEXT_SHIFT);

	/* Reset up-counter 0 */
	sys_write32(0, RTI_REG(RTIUC0));

	/* Configure the up counter prescaler, defaulted to 1 */
	uint32_t prescaler = 1;

	sys_write32(prescaler, RTI_REG(RTICPUC0));

	/* COUNTER CONFIGURATION END */

	/* Load timer compare value to compare block 0*/
	sys_write32((CYC_PER_TICK - 1), RTI_REG(RTICOMP0));

	/* Load counter compare update value to compare block 0*/
	sys_write32((CYC_PER_TICK), RTI_REG(RTIUDCP0));

	/* Use Compare block 0 for interrupt / tick generation */
	ti_rti_timer_write_reg_fields(0, RTI_REG(RTICOMPCTRL), RTICOMPCTRL_COMP0SEL_MASK,
				      RTICOMPCTRL_COMP0SEL_SHIFT);

	/* Clear Interrupt0 status */
	/* NOTE: Uses RTI Interrupt 0 (Interrupt generated by Compare Block 0) by default */
	ti_rti_timer_write_reg_fields(0, RTI_REG(RTIINTFLAG), RTIINTFLAG_INT0_MASK,
				      RTIINTFLAG_INT0_MASK);

	/* Enable Interrupt0 */
	ti_rti_timer_write_reg_fields(1, RTI_REG(RTISETINT), RTISETINT_SETINT0_MASK,
				      RTISETINT_SETINT0_SHIFT);

	/* Start the timer */
	ti_rti_timer_write_reg_fields(1, RTI_REG(RTIGCTRL), RTIGCTRL_CNT0EN_MASK,
				      RTIGCTRL_CNT0EN_SHIFT);

	irq_enable(TIMER_IRQ_NUM);

	return 0;
}

#define TI_RTI_TIMER(n)                                                                            \
	static struct ti_rti_timer_data ti_rti_timer_data_##n;                                     \
	static const struct ti_rti_timer_config ti_rti_timer_config_##n = {                        \
		DEVICE_MMIO_ROM_INIT(DT_DRV_INST(n)),                                              \
	};                                                                                         \
	DEVICE_DT_INST_DEFINE(n, NULL, NULL, &ti_rti_timer_data_##n, &ti_rti_timer_config_##n,     \
			      PRE_KERNEL_2, CONFIG_SYSTEM_CLOCK_INIT_PRIORITY, NULL);

DT_INST_FOREACH_STATUS_OKAY(TI_RTI_TIMER);

SYS_INIT(sys_clock_driver_init, PRE_KERNEL_2, CONFIG_SYSTEM_CLOCK_INIT_PRIORITY);
